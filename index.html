<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dinamik Tablo Bağımlılıkları</title>
    <!-- vis-network kütüphanesi -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <!-- PapaParse kütüphanesi (CSV işlemek için) -->
    <script type="text/javascript" src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>
    <style type="text/css">
        html, body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100%; height: 100%; margin: 0; padding: 0;
            overflow: hidden; background-color: #f4f6f9;
        }
        #main-container { display: flex; flex-direction: column; height: 100%; }
        #controls {
            padding: 10px 15px; background-color: #ffffff; border-bottom: 1px solid #dee2e6;
            display: flex; flex-wrap: wrap; align-items: center; gap: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-group label { font-weight: 600; color: #495057; margin-bottom: 0; }
        #node-search {
            padding: 6px 10px; min-width: 280px; border: 1px solid #ced4da;
            border-radius: 4px; font-size: 0.95em; transition: border-color 0.2s ease-in-out;
        }
        #node-search:focus {
             border-color: #80bdff; outline: 0; box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }
        #filter-container {
            display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
            max-height: 50px; overflow-y: auto;
        }
        #filter-container label {
            cursor: pointer; display: flex; align-items: center; gap: 4px;
            font-weight: normal; color: #333; padding: 3px 6px; border-radius: 3px;
            background-color: #f1f1f1; border: 1px solid #ddd;
            transition: background-color 0.2s ease; font-size: 0.9em;
        }
        #filter-container label:hover { background-color: #e2e6ea; }
        #filter-container input[type="checkbox"] { margin-right: 4px; cursor: pointer; }
        #graph-container {
            flex-grow: 1; background-color: #ffffff; position: relative; min-height: 200px;
        }
        #loading-message, #error-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.2em; color: #555; display: none;
            background-color: rgba(255, 255, 255, 0.9); padding: 20px;
            border-radius: 8px; z-index: 10; box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #error-message { color: #dc3545; max-width: 80%; line-height: 1.5; }
        .vis-navigation .vis-button {
             background-color: rgba(0, 123, 255, 0.7) !important; color: white !important;
             border: none !important; box-shadow: 0 2px 5px rgba(0,0,0,0.2) !important;
        }
         .vis-navigation .vis-button:hover { background-color: rgba(0, 105, 217, 0.8) !important; }
    </style>
</head>
<body>

<div id="main-container">
    <!-- Kontrol Alanı -->
    <div id="controls">
        <!-- Düğüm Arama -->
        <div class="control-group">
            <label for="node-search">Tablo Bul:</label>
            <input type="search" id="node-search" list="node-list" placeholder="Tablo ara veya seç...">
            <datalist id="node-list"></datalist>
        </div>
        <!-- Alan Filtreleri -->
        <div class="control-group">
            <label>Alana Göre Filtrele:</label>
            <div id="filter-container">
                <!-- Filtre onay kutuları buraya JS ile eklenecek -->
            </div>
        </div>
    </div>

    <!-- Grafik Konteyneri -->
    <div id="graph-container">
        <div id="loading-message">Veriler lib/table_relations.csv dosyasından yükleniyor...</div>
        <div id="error-message"></div>
    </div>
</div>

<!-- JavaScript -->
<script type="text/javascript">
    // --- Yapılandırma ---
    const csvPath = 'lib/table_relations.csv'; // index.html'e göre göreceli yol
    const nodeSizeRange = { min: 15, max: 45 }; // Düğüm boyut aralığı

    // --- vis-network Seçenekleri ---
    const visOptions = {
        layout: {
            hierarchical: {
                enabled: true, direction: "LR", sortMethod: "directed",
                levelSeparation: 300, nodeSpacing: 160, treeSpacing: 240
            }
        },
        physics: { // Kümelenmeyi azaltmak için hiyerarşik itme
            enabled: true, solver: "hierarchicalRepulsion",
            hierarchicalRepulsion: {
                centralGravity: 0.15, springLength: 170, springConstant: 0.02,
                nodeDistance: 220, damping: 0.1
            },
            minVelocity: 0.75,
            stabilization: { enabled: true, iterations: 250, updateInterval: 20 }
        },
        nodes: { // Düğüm stilleri
            borderWidth: 1.5, borderWidthSelected: 3,
            shape: "box",
            shapeProperties: { borderRadius: 3 },
            font: { size: 14, face: "'Segoe UI', Tahoma, sans-serif", color: "#212529" },
            color: {
                border: "#adb5bd", background: "#e9ecef",
                highlight: { border: "#e60000", background: "#ffcccc" },
                hover: { border: "#6c757d", background: "#dee2e6" }
            },
             scaling: { min: nodeSizeRange.min, max: nodeSizeRange.max }
        },
        edges: { // Kenar (ok) stilleri
            arrows: { to: { enabled: true, scaleFactor: 0.9, type: "arrow" } },
            color: { color: "#ced4da", highlight: "#e60000", hover: "#adb5bd", inherit: false },
            smooth: { enabled: true, type: "cubicBezier", forceDirection: "horizontal", roundness: 0.4 },
            width: 1.5, hoverWidth: 2, selectionWidth: 2.5
        },
        interaction: { // Kullanıcı etkileşimleri
            hover: true, tooltipDelay: 250, navigationButtons: true,
            keyboard: true, selectConnectedEdges: true, hoverConnectedEdges: true,
            dragNodes: true, dragView: true, zoomView: true
        },
        // Koşullu stil için gruplar
        groups: {
            Staging: { color: { background: "#fff3cd", border: "#ffe69c" }, shape: "database" },
            Dimension: { color: { background: "#d1e7dd", border: "#a3cfbb" }, shape: "ellipse" },
            Fact: { color: { background: "#cfe2ff", border: "#a6c9ff" }, shape: "box", font: {bold: {size: 16}} },
            Aggregate: { color: { background: "#e2d9f3", border: "#c5b6e3" }, shape: "hexagon" },
            Reporting: { color: { background: "#f8d7da", border: "#f5c2c7" }, shape: "star" },
            Mart: { color: { background: "#d4edda", border: "#b3dfca" }, shape: "diamond" },
            Source: { color: { background: "#dee2e6", border: "#adb5bd" }, shape: "dot", size: nodeSizeRange.min },
            Other: { color: { background: "#e9ecef", border: "#adb5bd" } }
        },
        // Configure bloğu yerleşik yapılandırma arayüzü içindir, devre dışı bırakıldı
        configure: { enabled: false } // Alt barı kapatır
    };

    // --- Global Değişkenler ---
    let network = null; // vis.Network örneği
    let allNodes = new vis.DataSet(); // CSV'den gelen TÜM düğümleri tutar
    let allEdges = new vis.DataSet(); // CSV'den gelen TÜM kenarları tutar
    const areas = new Set(); // Filtreleme için benzersiz alanları saklamak için

    // --- DOM Element Referansları ---
    const container = document.getElementById('graph-container');
    const loadingMessage = document.getElementById('loading-message');
    const errorMessage = document.getElementById('error-message');
    const nodeSearchInput = document.getElementById('node-search');
    const nodeDataList = document.getElementById('node-list');
    const filterContainer = document.getElementById('filter-container');

    // --- Başlatma ---
    document.addEventListener('DOMContentLoaded', loadAndProcessData);

    // --- Veri Yükleme ve İşleme ---
    function loadAndProcessData() {
        loadingMessage.style.display = 'block';
        errorMessage.style.display = 'none';
        console.log("CSV getirme deneniyor:", csvPath);

        fetch(csvPath)
            .then(response => {
                console.log("Fetch yanıt durumu:", response.status);
                if (!response.ok) {
                    throw new Error(`HTTP hatası ${response.status}: ${csvPath} alınamadı. Dosya yolu doğru mu ve bir web sunucusu ile doğru şekilde sunuluyor mu? ('python -m http.server' gibi)`);
                }
                return response.text();
            })
            .then(csvText => {
                console.log("CSV metni yüklendi, ayrıştırılıyor...");
                Papa.parse(csvText, {
                    header: true, skipEmptyLines: true,
                    complete: (results) => {
                        console.log("Ayrıştırma tamamlandı. Satır sayısı:", results.data.length);
                        if (results.errors.length > 0) console.warn("CSV Ayrıştırma hataları:", results.errors);
                        if (results.data.length === 0) throw new Error("CSV dosyası boş veya geçersiz.");
                        processData(results.data);
                    },
                    error: (error) => { throw new Error("CSV Ayrıştırma Hatası: " + error.message); }
                });
            })
            .catch(handleError);
    }

    function processData(data) {
    console.log("Veri işleniyor...");
    const nodesMap = new Map();
    const edgesSet = new Set(); // *** Değişiklik: Mükerrer kenarları önlemek için Set kullan ***
    const edgesArray = [];
    const degrees = {};
    areas.clear();

    data.forEach(row => {
        const source = row.source_table_name?.trim();
        const target = row.target_table_name?.trim();

        if (source && target && source !== target) {
            // *** Değişiklik: Kenarı Set'e eklemeden önce kontrol et ***
            const edgeKey = `${source}->${target}`; // Benzersiz kenar anahtarı
            if (!edgesSet.has(edgeKey)) { // Bu ilişki daha önce eklenmediyse
                edgesSet.add(edgeKey); // Set'e ekle

                // Düğümleri ekle (varsa tekrar eklemez)
                if (!nodesMap.has(source)) nodesMap.set(source, { id: source, label: source });
                if (!nodesMap.has(target)) nodesMap.set(target, { id: target, label: target });

                // Benzersiz kenarı diziye ekle (ID ile birlikte)
                edgesArray.push({ from: source, to: target, id: edgeKey });

                // Dereceleri sadece benzersiz ilişki için güncelle
                degrees[source] = (degrees[source] || 0) + 1;
                degrees[target] = (degrees[target] || 0) + 1;
            } else {
                // console.log(`Mükerrer ilişki atlandı: ${edgeKey}`); // İsteğe bağlı: Mükerrerleri logla
            }
        } else if (source && !target) {
             // Sadece kaynak olan düğümlerin eklenmesi (değişiklik yok)
            if (!nodesMap.has(source)) nodesMap.set(source, { id: source, label: source });
            degrees[source] = (degrees[source] || 0);
        } // İsterseniz sadece target olanları da ekleyebilirsiniz
    });

    // --- Buradan sonrası aynı kalıyor ---
    const nodesArray = []; const nodeIds = Array.from(nodesMap.keys());
    const minDeg = Math.min(0, ...Object.values(degrees)); const maxDeg = Math.max(1, ...Object.values(degrees));

    nodeIds.forEach(nodeId => {
        const nodeData = nodesMap.get(nodeId); const degree = degrees[nodeId] || 0;
        let size = (nodeSizeRange.min + nodeSizeRange.max) / 2;
        if (maxDeg > minDeg) {
            const normalizedDeg = (degree - minDeg) / (maxDeg - minDeg);
            size = nodeSizeRange.min + normalizedDeg * (nodeSizeRange.max - nodeSizeRange.min);
        }
        nodeData.size = size;
        const parts = nodeId.split('_'); const prefix = parts[0]?.toLowerCase();
        const area = parts.length > 1 ? parts[1] : 'Diğer';
        nodeData.area = area; areas.add(area);
        let group = 'Other';
        if (prefix === 'stg') group = 'Staging'; else if (prefix === 'dim') group = 'Dimension';
        else if (prefix === 'fct' || prefix === 'fact') group = 'Fact'; else if (prefix === 'agg') group = 'Aggregate';
        else if (prefix === 'rpt') group = 'Reporting'; else if (prefix === 'mrt') group = 'Mart';
        else if (prefix === 'src') group = 'Source';
        nodeData.group = group;
        nodesArray.push(nodeData);
    });

    console.log(`İşlendi (Benzersiz): ${nodesArray.length} düğüm, ${edgesArray.length} kenar.`); // Log mesajını güncelle
    allNodes = new vis.DataSet(nodesArray);
    allEdges = new vis.DataSet(edgesArray); // Artık benzersiz kenarlar içeriyor

    nodeDataList.innerHTML = nodeIds.sort().map(id => `<option value="${id}"></option>`).join('');
    populateAreaFilters();
    initializeNetwork(); // Ağı başlat
}

     function populateAreaFilters() {
        filterContainer.innerHTML = '';
        const sortedAreas = Array.from(areas).sort();
        const allLabel = document.createElement('label');
        allLabel.innerHTML = `<input type="checkbox" id="filter-all-areas" value="all" checked> Tüm Alanlar`;
        filterContainer.appendChild(allLabel);
        allLabel.querySelector('input').addEventListener('change', handleAreaFilterChange);
        sortedAreas.forEach(area => {
            const label = document.createElement('label');
            const areaId = `filter-area-${area.replace(/[^a-zA-Z0-9]/g, '_')}`;
            label.innerHTML = `<input type="checkbox" id="${areaId}" value="${area}"> ${area}`;
            filterContainer.appendChild(label);
            label.querySelector('input').addEventListener('change', handleAreaFilterChange);
        });
    }

    function handleAreaFilterChange(event) {
        const checkbox = event.target; const isAllCheckbox = checkbox.value === 'all';
        const areaCheckboxes = filterContainer.querySelectorAll('input[type="checkbox"]:not(#filter-all-areas)');
        if (isAllCheckbox) { if (checkbox.checked) areaCheckboxes.forEach(cb => cb.checked = false); }
        else { if (checkbox.checked) document.getElementById('filter-all-areas').checked = false; }
        const anyAreaChecked = Array.from(areaCheckboxes).some(cb => cb.checked);
        if (!isAllCheckbox && !anyAreaChecked) document.getElementById('filter-all-areas').checked = true;
        applyFilters();
    }

    function applyFilters() {
        const showAllAreas = document.getElementById('filter-all-areas').checked;
        const selectedAreas = new Set( Array.from(filterContainer.querySelectorAll('input[type="checkbox"]:checked:not(#filter-all-areas)')).map(cb => cb.value) );
        console.log("Filtreler uygulanıyor - Tümünü Göster:", showAllAreas, "Seçili Alanlar:", selectedAreas);
        const nodeFilterFn = (node) => showAllAreas || selectedAreas.has(node.area);
        // Yeni DataView'lar OLUŞTURULUYOR (setOptions yerine)
        const newNodeView = new vis.DataView(allNodes, { filter: nodeFilterFn });
        const visibleNodeIds = new Set(newNodeView.getIds()); console.log("Görünür düğüm sayısı:", visibleNodeIds.size);
        const edgeFilterFn = (edge) => visibleNodeIds.has(edge.from) && visibleNodeIds.has(edge.to);
        const newEdgeView = new vis.DataView(allEdges, { filter: edgeFilterFn }); console.log("Kenar görünümü filtrelendi. Kenar sayısı:", newEdgeView.length);
        // Ağı yeni DataView'lar ile GÜNCELLE
        if (network) {
            console.log("Ağ verisi yeni görünümlerle güncelleniyor...");
            network.setData({ nodes: newNodeView, edges: newEdgeView });
            console.log("Ağ verisi güncellendi.");
        } else { console.warn("Filtreler uygulanırken ağ henüz başlatılmamış."); }
    }

    function initializeNetwork() {
        console.log("vis.Network başlatılıyor...");
        // Başlangıç filtrelerini uygula ve ilk DataView'ları al
        const initialNodeFilterFn = (node) => document.getElementById('filter-all-areas').checked || new Set( Array.from(filterContainer.querySelectorAll('input[type="checkbox"]:checked:not(#filter-all-areas)')).map(cb => cb.value)).has(node.area);
        const initialNodeView = new vis.DataView(allNodes, { filter: initialNodeFilterFn });
        const initialVisibleNodeIds = new Set(initialNodeView.getIds());
        const initialEdgeFilterFn = (edge) => initialVisibleNodeIds.has(edge.from) && initialVisibleNodeIds.has(edge.to);
        const initialEdgeView = new vis.DataView(allEdges, { filter: initialEdgeFilterFn });
        const data = { nodes: initialNodeView, edges: initialEdgeView };

        try {
             if(network) { network.destroy(); network = null; }
             network = new vis.Network(container, data, visOptions); // Ağı ilk görünümlerle başlat
             console.log("vis.Network başarıyla başlatıldı.");
             loadingMessage.style.display = 'none';
             network.on("stabilizationIterationsDone", () => console.log("Ağ stabilize oldu."));
             network.on("error", handleError);
             nodeSearchInput.addEventListener('change', (e) => focusOnNode(e.target.value));
        } catch (e) { console.error("vis.Network başlatılamadı:", e); handleError(e); }
    }

    function focusOnNode(nodeId) {
        if (network && nodeId && allNodes.get(nodeId)) { // Düğüm veride var mı?
            console.log("Düğüme odaklanılıyor:", nodeId);
            try {
                network.focus(nodeId, { scale: 1.2, animation: { duration: 600, easingFunction: 'easeInOutCubic' } });
                network.selectNodes([nodeId], true); // Seç ve vurgula
                // Ağın mevcut düğümlerini alarak görünürlüğü kontrol etme (daha az güvenilir olabilir)
                 const currentNodesInView = network.body.data.nodes.getIds();
                 if (!currentNodesInView.includes(nodeId)) {
                     // Biraz gecikmeyle uyarı ver, belki DOM henüz tam güncellenmemiştir
                      setTimeout(() => {
                        if (!network.body.data.nodes.getIds().includes(nodeId)) {
                           alert(`'${nodeId}' tablosu mevcut ancak geçerli filtrelere göre gizli.`);
                         }
                      }, 100);
                 }
            } catch (focusError) {
                 console.warn("Odaklanma sırasında hata (muhtemelen düğüm görünür değil):", focusError);
                 alert(`'${nodeId}' tablosuna odaklanırken bir sorun oluştu (gizlenmiş olabilir).`);
            }
        } else if (nodeId) {
            console.warn("Düğüm bulunamadı:", nodeId);
            alert(`'${nodeId}' tablosu veride bulunamadı.`);
            if(network) network.unselectAll();
        } else { if(network) network.unselectAll(); }
    }

    function handleError(error) {
        console.error('Hata:', error);
        loadingMessage.style.display = 'none';
        errorMessage.textContent = `Hata: ${error.message || 'Bilinmeyen bir hata oluştu.'}`;
        errorMessage.style.display = 'block';
        if (network) { try { network.destroy(); } catch(e) {} network = null; }
    }
</script>

</body>
</html>
