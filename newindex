<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etkileşimli Bağımlılık Zinciri Keşfi</title>
    <!-- YEREL Kütüphane Yolları -->
    <script type="text/javascript" src="lib/vis-network.min.js"></script>
    <script type="text/javascript" src="lib/papaparse.min.js"></script>
    <script src="lib/tagify.js"></script>
    <script src="lib/tagify.polyfills.min.js"></script>
    <link href="lib/tagify.css" rel="stylesheet" type="text/css" />

    <style type="text/css">
        /* Önceki stiller aynı kalıyor */
        html, body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #f4f6f9; }
        #main-container { display: flex; flex-direction: column; height: 100%; }
        #controls { padding: 10px 15px; background-color: #ffffff; border-bottom: 1px solid #dee2e6; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-group label, .control-group span { font-weight: 600; color: #495057; margin-bottom: 0; white-space: nowrap; }
        .control-group input[type="checkbox"] { margin-right: 4px; cursor: pointer; }
        #node-tag-input { min-width: 350px; flex-grow: 1; /* Tagify kendi stilini uygular */ }
        .tagify__dropdown{ z-index: 9999; }
        #generate-button { padding: 7px 15px; font-size: 1em; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s ease; }
        #generate-button:hover { background-color: #0056b3; }
        #generate-button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #graph-container { flex-grow: 1; background-color: #ffffff; position: relative; min-height: 300px; border-top: 1px solid #dee2e6; }
        #message-area { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: #555; text-align: center; background-color: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 8px; z-index: 10; box-shadow: 0 4px 8px rgba(0,0,0,0.1); display: block; }
        #message-area.loading { color: #0056b3; }
        #message-area.error { color: #dc3545; }
        #message-area.hidden { display: none; }
        .vis-navigation .vis-button { background-color: rgba(0, 123, 255, 0.7) !important; color: white !important; border: none !important; box-shadow: 0 2px 5px rgba(0,0,0,0.2) !important; }
        .vis-navigation .vis-button:hover { background-color: rgba(0, 105, 217, 0.8) !important; }
        #context-menu { position: absolute; background-color: #f9f9f9; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); padding: 5px 0; min-width: 120px; z-index: 1000; display: none; border-radius: 4px; }
        #context-menu button { display: block; width: 100%; padding: 8px 15px; border: none; background: none; text-align: left; cursor: pointer; font-size: 0.95em; }
        #context-menu button:hover { background-color: #eee; }
    </style>
</head>
<body>

<div id="main-container">
    <div id="controls">
        <div class="control-group" style="flex-grow: 1;">
            <label for="node-tag-input">Tablo Ekle:</label>
            <input id="node-tag-input" placeholder="Tablo adlarını yazın veya seçin...">
        </div>
        <div class="control-group">
            <input type="checkbox" id="toggle-hierarchy" checked>
            <label for="toggle-hierarchy">Hiyerarşik Düzen</label>
            <input type="checkbox" id="toggle-physics">
            <label for="toggle-physics">Fiziği Etkinleştir</label>
        </div>
         <div class="control-group">
             <button id="generate-button" disabled>Grafiği Oluştur</button>
         </div>
    </div>
    <div id="graph-container">
        <div id="message-area">Başlamak için tablo(lar) ekleyin ve 'Grafiği Oluştur'a tıklayın.</div>
    </div>
    <div id="context-menu">
        <button id="copy-node-name-button">İsmi Kopyala</button>
    </div>
</div>

<script type="text/javascript">
    // --- Yapılandırma ---
    const csvPath = 'lib/table_relations.csv';
    const nodeSizeRange = { min: 15, max: 45 };

    // --- vis-network Varsayılan Seçenekleri ---
    // Başlangıç: Hiyerarşi AÇIK, Fizik KAPALI
    const defaultVisOptions = {
        layout: { hierarchical: { enabled: true, direction: "LR", sortMethod: "directed",
            // Hiyerarşik düzen için daha sıkı ayarlar (uzun okları azaltmaya yönelik)
            levelSeparation: 180, // Seviyeler arası mesafeyi azalt
            nodeSpacing: 100,     // Düğümler arası mesafeyi azalt
            treeSpacing: 150,     // Ağaçlar arası mesafeyi azalt
            blockShifting: true,
            edgeMinimization: true,
            parentCentralization: true
        }},
        physics: { enabled: false },
        // Diğer seçenekler (nodes, edges, interaction, groups, configure) öncekiyle aynı
        nodes: { borderWidth: 1.5, borderWidthSelected: 3, shape: "box", shapeProperties: { borderRadius: 3 }, font: { size: 14, face: "'Segoe UI', Tahoma, sans-serif", color: "#212529" }, color: { border: "#adb5bd", background: "#e9ecef", highlight: { border: "#e60000", background: "#ffcccc" }, hover: { border: "#6c757d", background: "#dee2e6" } }, scaling: { min: nodeSizeRange.min, max: nodeSizeRange.max } },
        edges: { arrows: { to: { enabled: true, scaleFactor: 0.8, type: "arrow" } }, color: { color: "#c0c0c0", highlight: "#e60000", hover: "#a0a0a0", inherit: false }, smooth: { enabled: true, type: "cubicBezier", forceDirection: "horizontal", roundness: 0.2 }, width: 1.2, hoverWidth: 1.8, selectionWidth: 2.2 }, // roundness, width azaltıldı
        interaction: { hover: true, tooltipDelay: 250, navigationButtons: true, keyboard: true, selectConnectedEdges: true, hoverConnectedEdges: true, dragNodes: true, dragView: true, zoomView: true },
        groups: { Staging: { color: { background: "#fff3cd", border: "#ffe69c" }, shape: "database" }, Dimension: { color: { background: "#d1e7dd", border: "#a3cfbb" }, shape: "ellipse" }, Fact: { color: { background: "#cfe2ff", border: "#a6c9ff" }, shape: "box", font: {bold: {size: 16}} }, Aggregate: { color: { background: "#e2d9f3", border: "#c5b6e3" }, shape: "hexagon" }, Reporting: { color: { background: "#f8d7da", border: "#f5c2c7" }, shape: "star" }, Mart: { color: { background: "#d4edda", border: "#b3dfca" }, shape: "diamond" }, Source: { color: { background: "#dee2e6", border: "#adb5bd" }, shape: "dot", size: nodeSizeRange.min }, Other: { color: { background: "#e9ecef", border: "#adb5bd" } } },
        configure: { enabled: false }
    };

    const hierarchicalOptions = { // Hiyerarşik açıkken kullanılacak ayarlar
        layout: { hierarchical: { enabled: true, direction: "LR", sortMethod: "directed", levelSeparation: 180, nodeSpacing: 100, treeSpacing: 150, blockShifting: true, edgeMinimization: true, parentCentralization: true } },
        physics: {
            solver: 'hierarchicalRepulsion',
            hierarchicalRepulsion: { // Hiyerarşik için fizik ayarları
                centralGravity: 0.1, // Çekimi azalt
                springLength: 100,   // Yayları kısalt
                springConstant: 0.08, // Yayları biraz daha sert yap
                nodeDistance: 120,   // Düğüm mesafesini ayarla
                damping: 0.15
            },
            stabilization: { enabled: true, iterations: 150, updateInterval: 20 }
        }
    };
    const nonHierarchicalOptions = { // Hiyerarşik kapalıyken kullanılacak ayarlar
        layout: { hierarchical: { enabled: false } },
        physics: {
            solver: 'barnesHut',
            barnesHut: { gravitationalConstant: -30000, centralGravity: 0.05, springLength: 120, springConstant: 0.03, damping: 0.1, avoidOverlap: 0.3 },
            stabilization: { enabled: true, iterations: 120, updateInterval: 25 }
        }
    };

    // --- Global Değişkenler ---
    let network = null; let allNodesData = new Map(); let allEdgesData = [];
    let outgoingEdgesMap = new Map(); let incomingEdgesMap = new Map();
    let selectedStartNodes = new Set(); let tagifyInstance = null;

    // --- DOM Element Referansları ---
    const container = document.getElementById('graph-container');
    const messageArea = document.getElementById('message-area');
    const nodeTagInput = document.getElementById('node-tag-input');
    const generateButton = document.getElementById('generate-button');
    const contextMenu = document.getElementById('context-menu');
    const copyNameButton = document.getElementById('copy-node-name-button');
    const hierarchyCheckbox = document.getElementById('toggle-hierarchy');
    const physicsCheckbox = document.getElementById('toggle-physics');
    let contextNodeId = null;

    // --- Başlatma ---
    document.addEventListener('DOMContentLoaded', () => {
        setMessage("Veri yükleniyor...", "loading"); generateButton.disabled = true;
        hierarchyCheckbox.checked = defaultVisOptions.layout.hierarchical.enabled;
        physicsCheckbox.checked = defaultVisOptions.physics.enabled;
        tagifyInstance = new Tagify(nodeTagInput, { whitelist: [], dropdown: { maxItems: 15, enabled: 0, closeOnSelect: true, highlightFirst: true }, enforceWhitelist: true, delimiters: ",|\t" });
        tagifyInstance.on('add', onTagAdd); tagifyInstance.on('remove', onTagRemove);
        loadAndProcessData();
        generateButton.addEventListener('click', handleGenerateButtonClick);
        copyNameButton.addEventListener('click', handleCopyName);
        document.addEventListener('click', hideContextMenu);
        hierarchyCheckbox.addEventListener('change', updateNetworkOptions);
        physicsCheckbox.addEventListener('change', updateNetworkOptions);
    });

    // --- Tagify Olay İşleyicileri ---
    function onTagAdd(e) { selectedStartNodes.add(e.detail.data.value); generateButton.disabled = selectedStartNodes.size === 0; }
    function onTagRemove(e) { selectedStartNodes.delete(e.detail.data.value); generateButton.disabled = selectedStartNodes.size === 0; }

    // --- Mesaj Yönetimi ---
    function setMessage(text, type = "info") { messageArea.textContent = text; messageArea.className = type; showMessage(); }
    function hideMessage() { messageArea.classList.add("hidden"); }
    function showMessage() { messageArea.classList.remove("hidden"); }

    // --- Veri Yükleme ve Ön İşleme ---
    function loadAndProcessData() { fetch(csvPath).then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}: ${csvPath}`); return r.text(); }).then(txt => { Papa.parse(txt, { header: true, skipEmptyLines: true, complete: (res) => { if (res.errors.length) console.warn("CSV Hataları:", res.errors); if (!res.data.length) throw new Error("CSV boş."); preprocessData(res.data); setMessage("Tablo(lar) ekleyin ve 'Grafiği Oluştur'a tıklayın."); }, error: (err) => { throw new Error("CSV Ayrıştırma: " + err.message); } }); }).catch(handleError); }
    function preprocessData(data) { console.log("Ön işleme..."); allNodesData.clear(); allEdgesData = []; outgoingEdgesMap.clear(); incomingEdgesMap.clear(); const eSet = new Set(); const deg = {}; data.forEach(r => { const s = r.source_table_name?.trim(); const t = r.target_table_name?.trim(); if (s && t && s !== t) { const k = `${s}->${t}`; if (!eSet.has(k)) { eSet.add(k); const e = { from: s, to: t, id: k }; allEdgesData.push(e); [s, t].forEach(nId => { if (!allNodesData.has(nId)) { allNodesData.set(nId, { id: nId, label: nId }); deg[nId] = 0; } }); deg[s]++; deg[t]++; if (!outgoingEdgesMap.has(s)) outgoingEdgesMap.set(s, new Set()); outgoingEdgesMap.get(s).add(e); if (!incomingEdgesMap.has(t)) incomingEdgesMap.set(t, new Set()); incomingEdgesMap.get(t).add(e); } } }); const nIds = Array.from(allNodesData.keys()); const minD = Math.min(0,...Object.values(deg)); const maxD = Math.max(1,...Object.values(deg)); nIds.forEach(nId => { const nData = allNodesData.get(nId); const d = deg[nId] || 0; let sz = (nodeSizeRange.min+nodeSizeRange.max)/2; if (maxD > minD) { const n = (d-minD)/(maxD-minD); sz = nodeSizeRange.min + n*(nodeSizeRange.max-nodeSizeRange.min); } nData.size = sz; const p = nId.split('_'); const pf = p[0]?.toLowerCase(); const a = p.length > 1 ? p[1] : 'Diğer'; nData.area = a; let g = 'Other'; if (pf==='stg') g='Staging'; else if (pf==='dim') g='Dimension'; else if (pf==='fct'||pf==='fact') g='Fact'; else if (pf==='agg') g='Aggregate'; else if (pf==='rpt') g='Reporting'; else if (pf==='mrt') g='Mart'; else if (pf==='src') g='Source'; nData.group = g; }); console.log(`Ön işleme: ${allNodesData.size} düğüm, ${allEdgesData.length} kenar.`); if (tagifyInstance) { tagifyInstance.settings.whitelist = nIds.sort(); } }

    // --- Zincir Bulma ---
    function findDependencyChain(startNodeId) { const chainNodes = new Set(); const chainEdges = new Set(); if (!allNodesData.has(startNodeId)) return null; chainNodes.add(startNodeId); const vDown = new Set([startNodeId]); const dQ = [startNodeId]; let h = 0; while(h < dQ.length){ const c = dQ[h++]; if (outgoingEdgesMap.has(c)) { outgoingEdgesMap.get(c).forEach(e => { chainEdges.add(e); chainNodes.add(e.to); if (!vDown.has(e.to)) { vDown.add(e.to); dQ.push(e.to); } }); } } const vUp = new Set([startNodeId]); const uQ = [startNodeId]; h = 0; while(h < uQ.length){ const c = uQ[h++]; if (incomingEdgesMap.has(c)) { incomingEdgesMap.get(c).forEach(e => { chainEdges.add(e); chainNodes.add(e.from); if (!vUp.has(e.from)) { vUp.add(e.from); uQ.push(e.from); } }); } } return { nodes: Array.from(chainNodes), edges: Array.from(chainEdges) }; }

    // --- Grafik Oluşturma ve Güncelleme ---
    function handleGenerateButtonClick() { const validStartNodeIds = Array.from(selectedStartNodes); if (!validStartNodeIds.length) { setMessage("Tablo ekleyin.", "error"); return; } setMessage("Oluşturuluyor...", "loading"); generateButton.disabled = true; setTimeout(() => { try { const cNodes = new Set(); const cEdges = new Map(); validStartNodeIds.forEach(sId => { const ch = findDependencyChain(sId); if (ch) { ch.nodes.forEach(n => cNodes.add(n)); ch.edges.forEach(e => cEdges.set(e.id, e)); } }); console.log(`Birleşik: ${cNodes.size} düğüm, ${cEdges.size} kenar.`); if (!cNodes.size) throw new Error(`Zincir bulunamadı.`); if (cNodes.size <= validStartNodeIds.length && !cEdges.size) { setMessage(`Bağımlılık yok.`, "info"); if (network) network.destroy(); network = null; showMessage(); generateButton.disabled = !selectedStartNodes.size; return; } const nGraph = Array.from(cNodes).map(nId => { const nD = { ...allNodesData.get(nId) }; delete nD.x; delete nD.y; return nD; }); const eGraph = Array.from(cEdges.values()); renderChainGraph(new vis.DataSet(nGraph), new vis.DataSet(eGraph), validStartNodeIds); hideMessage(); } catch (err) { handleError(err); } finally { generateButton.disabled = !selectedStartNodes.size; } }, 10); }
    function renderChainGraph(nodesDataSet, edgesDataSet, startNodeIds) { console.log("Grafik oluşturuluyor..."); const data = { nodes: nodesDataSet, edges: edgesDataSet }; try { if(network) network.destroy(); network = null; const currentOpts = getCurrentVisOptions(); network = new vis.Network(container, data, currentOpts); console.log("Grafik oluşturuldu."); network.once("stabilizationIterationsDone", () => { console.log("Stabilize oldu. Fit."); if (startNodeIds?.length) network.focus(startNodeIds[0], { scale: 1.0, animation: { duration: 500 } }); else network.fit({ animation: { duration: 500 } }); }); network.on("oncontext", handleRightClick); network.on("error", handleError); } catch (e) { console.error("Grafik hatası:", e); handleError(e); } }

    // --- Ağ Seçeneklerini Güncelleme ---
    function updateNetworkOptions() { if (!network) { console.log("Ağ yok."); return; } console.log("Seçenekler güncelleniyor..."); const optsToUpdate = getCurrentVisOptions(); try { network.setOptions(optsToUpdate); console.log("Güncellendi."); } catch (err) { console.error("Güncelleme hatası:", err); alert("Görünüm hatası."); } }
    function getCurrentVisOptions() { const isHier = hierarchyCheckbox.checked; const isPhysEn = physicsCheckbox.checked; let layoutOpts, physOptsConfig; if (isHier) { layoutOpts = hierarchicalOptions.layout; physOptsConfig = hierarchicalOptions.physics; } else { layoutOpts = nonHierarchicalOptions.layout; physOptsConfig = nonHierarchicalOptions.physics; } const finalPhysOpts = { ...physOptsConfig, enabled: isPhysEn }; return { ...defaultVisOptions, layout: layoutOpts, physics: finalPhysOpts }; }

    // --- Sağ Tık ve Kopyalama İşlevleri ---
    function handleRightClick(params) { params.event.preventDefault(); hideContextMenu(); const nId = network.getNodeAt(params.pointer.DOM); if (nId) { contextNodeId = nId; contextMenu.style.top = `${params.event.clientY}px`; contextMenu.style.left = `${params.event.clientX}px`; contextMenu.style.display = 'block'; } else { contextNodeId = null; } }
    function hideContextMenu() { contextMenu.style.display = 'none'; contextNodeId = null; }
    function handleCopyName() {
        if (contextNodeId) {
            const nodeLabel = allNodesData.get(contextNodeId)?.label || contextNodeId;
            try {
                // Asenkron Clipboard API'sini kullanmayı dene
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(nodeLabel)
                        .then(() => {
                            console.log("İsim kopyalandı:", nodeLabel);
                            const originalText = copyNameButton.textContent;
                            copyNameButton.textContent = 'Kopyalandı!';
                            setTimeout(() => { copyNameButton.textContent = originalText; }, 1500);
                        })
                        .catch(err => {
                            console.error('Async kopyalama başarısız:', err);
                            fallbackCopyTextToClipboard(nodeLabel); // Yedek yöntemi dene
                        });
                } else {
                    fallbackCopyTextToClipboard(nodeLabel); // API yoksa yedek yöntemi dene
                }
            } catch (err) {
                console.error('Kopyalama sırasında genel hata:', err);
                alert('İsim panoya kopyalanamadı. Tarayıcınız bu özelliği desteklemiyor olabilir veya izinler eksik olabilir.');
            }
        }
        hideContextMenu();
    }
    // Clipboard API'si için yedek kopyalama fonksiyonu (eski yöntem)
    function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed"; // Görünümden çıkar
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            const successful = document.execCommand('copy');
            const msg = successful ? 'Kopyalandı!' : 'Kopyalanamadı (eski yöntem).';
            if (successful) {
                console.log("İsim kopyalandı (eski yöntem):", text);
                const originalText = copyNameButton.textContent;
                copyNameButton.textContent = msg;
                setTimeout(() => { copyNameButton.textContent = originalText; }, 1500);
            } else {
                 alert('İsim panoya kopyalanamadı (eski yöntem). Manuel olarak kopyalamayı deneyin.');
            }
        } catch (err) {
            console.error('Eski yöntemle kopyalama başarısız:', err);
            alert('İsim panoya kopyalanamadı. Tarayıcınız bu özelliği desteklemiyor olabilir.');
        }
        document.body.removeChild(textArea);
    }

    // --- Hata İşleme ---
    function handleError(error) { console.error('Hata:', error); setMessage(`Hata: ${error.message || 'Bilinmeyen.'}`, "error"); showMessage(); if (network) { try { network.destroy(); } catch(e) {} network = null; } generateButton.disabled = !selectedStartNodes.size; }
</script>

</body>
</html>
